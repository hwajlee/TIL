# 파이썬 프로그래밍의 기초 - 자료형2

**22년 12월 15일 (목)**

## `시퀀스(sequence) 자료형`
데이터가  순서대로 나열된 형식(정렬 아님 주의!)
1. 리스트(list) : mutable(변경가능)
2. 튜플(tuple) : immutable(불변)
3. 레인지(range) : immutable(불변)
4. 문자열(string) : immutable(불변)

> 코드 시각화
> https://pythontutor.com/


## 1. 리스트
- `변수명 = []`(권장), `변수명 = list()`로 생성 가능(형변환 할 때 유용) 
- 수정 가능
- 이차원 리스트 접근법 `변수명[][]`
대괄호 [], `list()` 사용

```python
# result [], []
empty_List = []
create_List = list()
print(empty_List, create_List)

# result ['강남', '서초', '송파', '광진', '마포']
locations = ['강남', '서초', '송파', '광진', '마포']
# locations = ['강남' '서초', '송파', '광진', '마포'] : 실행됨, 주의! 
numbers = [
    1,
    2,
    3,
    4
    5,
    6,
    7, # trailing comma
]
print(locations)
```

## 추가 (`append()`)
```python
# result ['강남', '서초', '송파', '광진', '마포', '부산']
locations = ['강남', '서초', '송파', '광진', '마포']
locations.apped('부산')
print(locations)

# result ['value', 'value', 'value', [10], [2]]
test_list = ['value', 'value', 'value', [], [1]]
test_list[3].append(10)
test_list[4][0].append(2)
print(test_list)
```

## 2. 튜플
- 수정 불가능 immutable
- () 표현
- 읽기 전용
- 하나의 항목으로 구성된 튜플은 값 뒤에 쉼표 붙여 만든다. `t = (1)`int로 인식함-> `t = (1,)`
- 파이썬 내부에서 사용중
```python
# result (1, 2, 3)
tuple_data = (1, 2, 3)
print(tuple_data)

# result (1, 2, 3)
tuple_data = 1, 2, 3
print(tuple_date)

# result [1, 100, 3]
list_data = [1, 2, 3]
list_data[1] = 100
print(list_data)

# Error
# tuple_data = 1, 2, 3
# tuple_data[1] = 100
```

## 3. range()
- 숫자의 시퀀스를 나타내기 위해 사용됨
- 기본형 : `range(n)`
  - 0부터 n-1까지
- 범위 지정 : `range(n, m)`
  - n부터 m-1까지
- 범위 및 스텝 지정 : `range(n, m, s)`
  - n부터 m-1까지 +s만큼 증가한다  
  - 예_) 0부터 -9까지 담긴 range만들기 `range(0, -10, -1)`
`range(n), range(n, m), range(n, m, sep)`

```python
import random
numbers = range(1, 46)
# result randomValue
print(random.choice(number))
# result randomValue
print(random.sample(number,2))

# result 0~-9
numbers = list(range(0, -10, -1))
print(numbers)

# result 2의 배수
numbers = list(range(0, 20, 2))
print(numbers)

# result [0, 0, 0, 0, 0, 0]
print([0] * 6)
```

## sort()
```python
import random
chois = 6
numbers = range(1, 46)
lucky = random.sample(numbers, chois)
lucky.sort()
print(lucky)
```


## indexing slicing
```python
locations = ['강남', '서초', '송파', '광진', '마포']

# result ['서초', '송파']
print(locations[1:3])

numbers = list(range(0, 31, 3))

# list[x:y:z] => x~y-1, step z
# result 1 3 5 7 9
print(numbers[1:10:2])
# result numbersValue 
print(numbers[:::])
```

## list method
`len()` : 배열 안의 갯수

`min(), max()` : 최소값, 최대값
```python
numbers = range(0, 31)
# result 30
print(len(numbers))

# result 0 30
print(min(numbers), max(numbers))
```
---
왜 **.붙은 함수**? 리스트에 **종속된 함수**다. 이는 **method**라 부른다.

## 시퀀스에서 활용할 수 있는 연산자/함수
|operation|설명|
|---------|---|
|x `in` s	|containment test|
|x `not in` s|containment test|
|s1 `+` s2|concatenation|
|s `*` n|n번만큼 반복하여 더하기
|`s[i]`|indexing|
|`s[i:j]`|slicing|
|`s[i:j:k]`|k간격으로 slicing|
|len(s)|길이|
|min(s)|최솟값|
|max(s)|최댓값|
|s.count(x)|x의 개수|

**slicing 예시**

- `list[x:y]` => idx x ~ idx y-1

- `list[x:y:z]` => idx x ~ idx y-1인데, step z

- `list[x::z]` => idx x ~ 끝까지 step z

- `list[::z]` => idx 처음 ~ 끝까지 step z

- `list[x:y:]` => idx x ~ idx y-1 step 1

- `list[::]` => idx 0 ~ 끝까지 step 1 = 그대로

---

## `set, dictionary`
> `set`(집합)순서가 없는 자료구조

> `dictionary`는 아이템이 삽입되는 순서를 가지고 있다.

### set

* 세트는 수학에서의 집합과 동일하게 처리된다. 

* 세트는 소괄호`()`를 통해 만들며, 순서가 없고 중복된 값이 없다.

* 빈 집합을 만들려면 `set()`을 사용해야 한다. `{}`로 사용 불가능.
  

|연산자/함수|설명|
|---|---|
|a `-` b|차집합|
|a `\|` b|합집합|
|a `&` b|교집합|
|a`.difference(b)`|차집합|
|a`.union(b)`|합집합|
|a`.intersection(b)`|교집합|

```python
my_numbers = set([26, 15, 29, 43, 2, 45])
jackpot_numbers = set([26, 15, 29, 43, 2, 34])
bonus_number = 45

# set의 교집합 활용
# intersects = list(set(my_numbers) & set(jackpot_numbers)) 교집합
# set_diff = list(set(my_numbers) - set(intersects)) 차집합
chk = len(my_numbers.intersection(jackpot_numbers))  #교집합

if chk == 6:
    print('1등입니다')
elif chk == 5:
    if bonus_number in my_numbers:
        print('2등입니다')
    else:
        print('3등입니다')
elif chk == 4:
    print('4등입니다')
elif chk == 3:
    print('5등입니다')
else:
    print('꽝')
```
```python
# 중복값을 제거하고 싶을때
list_data = [1, 2, 1, 3, 4, 1, 2]

# result 1, 2, 3
print(set(list_data))
```

```python
set_data1 = {1, 2, 3}
set_data2 = {3, 6, 9}

# 차집합 (빼고 남은거) result 1, 2
print(set_data1 - set_data2)

# 합집합 (다합침) result 1, 2, 3, 6, 9
print(set_data1 | set_data2)

# 교집합 (두개가 교차되는 것) result 3
print(set_data1 & set_data2)
```



### dictionary

* 딕셔너리는 `key`와 `value`가 쌍으로 이뤄져있으며, 궁극의 자료구조이다. 
* `{}`를 통해 만들며, `dict()`로 만들 수도 있다.
* `key`는 불변(immutable)한 모든 것이 가능하다. (불변값 : string, integer, float, boolean, tuple, range) 
* `key`값은 중복 불가능하다. 
* `value`는 `list`, `dictionary`를 포함한 모든 것이 가능하다.

`.keys()` 메소드를 활용하여 key를 확인 해볼 수 있다.

`.values()` 메소드를 활용하여 value를 확인 해볼 수 있다.

`.items()` 메소드를 활용하여 key, value를 확인 해볼 수 있다.

**우리가 받아오는 데이터는 거의 list, dictionary로 이뤄져있다.**

```
[
    {
        '이름':"유재석", '나이':23, '전공':"심리학"
        },
    {
        '이름':"김재석", '나이':32, '전공':"경제학"
        },
]
```
```python
dic_data = {
    '커피' : 'coffee',
    '우유' : 'milk',
    '물' : 'water'
}

real_data = [
    {
        '커피' : 'coffee',
        '우유' : 'milk',
        '물' : 'water'
    },
    {
        'name' : 'my',
        'contry' : '한국',
        'location' : '성동구'
    }
]

# key 값 확인
print(real_data.keys())

# value 값 확인
print(real_data.values())

# key, value 둘 다 확인
print(real_data.items())

# modify
dic_data['커피'] = '커피'
print(dic_data)

# append
dic_data['스무디'] = 'smoothie'
print(dic_data)
```
String은 immutable
